#pragma once
// 5*5 Map // 10 Move
// 1. 일반적인 경우
// 2. 벽에 막히는 경우
// 3. 같은 1에 또 오는 경우
// 4. 2,3 케이스 중첩
// 5. a,w,s,d 외 다른 원소가 포함된 경우
#define CASES 10
int caseArr[CASES][5][5] = {
	{
		{0,0,0,0,1},
		{0,1,0,0,0},
		{0,0,0,2,0},
		{0,1,0,0,1},
		{0,0,0,0,0}
	},
	{
		{0,0,0,0,1},
		{0,1,0,0,0},
		{0,0,0,2,0},
		{0,1,0,0,1},
		{0,0,0,0,0}
	},
	{
		{0,0,0,0,1},
		{0,1,0,0,0},
		{0,0,0,2,0},
		{0,1,0,0,1},
		{0,0,0,0,0}
	},
	{
		{0,0,0,0,1},
		{0,1,0,0,0},
		{0,0,0,2,0},
		{0,1,0,0,1},
		{0,0,0,0,0}
	},
	{
		{0,0,0,0,1},
		{0,1,0,0,0},
		{0,0,0,2,0},
		{0,1,0,0,1},
		{0,0,0,0,0}
	},
	{
		{0,0,0,0,1},
		{0,1,0,0,0},
		{0,0,0,2,0},
		{0,1,0,0,1},
		{0,0,0,0,0}
	},
	{
		{0,0,0,0,1},
		{0,1,0,0,0},
		{0,0,0,2,0},
		{0,1,0,0,1},
		{0,0,0,0,0}
	},
	{
		{0,0,0,0,1},
		{0,1,0,0,0},
		{0,0,0,2,0},
		{0,1,0,0,1},
		{0,0,0,0,0}
	},
	{
		{0,0,0,0,1},
		{0,1,0,0,0},
		{0,0,0,2,0},
		{0,1,0,0,1},
		{0,0,0,0,0}
	},
	{
		{0,0,0,0,1},
		{0,1,0,0,0},
		{0,0,0,2,0},
		{0,1,0,0,1},
		{0,0,0,0,0}
	}
};
char caseMove[CASES][10] = {
	{ 'w','a','a','s','s','d','d','d','w','w'}, // 일반적인 경우
	{ 'w','a','a','s','s','d','d','d','w','w'},
	{ 'w','a','a','s','s','d','d','d','s','w'}, // 같은 1에 또 오는 경우
	{ 'w','a','a','s','s','d','d','d','s','w'},
	{ 'w','d','d','w','s','s','s','s','s','s'}, // 벽 충돌 후 1 만나는 경우 // 2개 얻
	{ 'w','d','d','w','s','s','s','s','s','s'},
	{ 'd','d','s','w','s','w','w','w','w','w'}, // 벽 충돌 후  같은 1 을 또 만나는 경우 // 2개 얻
	{ 'd','d','s','w','s','w','w','w','w','w'},
	{ 'w','a','a','t','x','c','g','r','r','u'}, // wasd 말고 다른 문자가 들어가는 경우
	{ 'w','a','a','t','x','c','g','r','r','u'}
};
int answer[CASES] = { 3,3,3,3,2,2,2,2,1,1 };
